<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Tetris.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Tetris.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Import ramda.js library
import R from './ramda.js';

// Import the points system of the game
import Score from './Score.js';

/**
 * @namespace Tetris
 * @author A. Freddie Page
 * @version 2022.23
 */
const Tetris = {};

//----------------------------------------------------------------------------//
// ## Type Definitions                                                        //
//----------------------------------------------------------------------------//

/**
 * A Tetris Game is all the information required to represent the current state
 * of a game, i.e. the field of play, location of the current tetromino,
 * how to generate next pieces, and score.
 * @typedef {object} Game
 * @memberof Tetris
 * @property {Tetris.Tetromino_bag} bag New pieces get drawn from the bag.
 * @property {Tetris.Tetromino} current_tetromino
 *     The tetromino in play descending in the field.
 * @property {Tetris.Field} field The grid containing locked in pieces.
 * @property {boolean} game_over Whether this game has ended.
 * @property {Tetris.Tetromino} next_tetromino The next piece to descend.
 * @property {number[]} position Where in the field is the current tetromino.
 * @property {Score.Score} score Information relating to the score of the game.
 */

/**
 * A field is the grid whose cells contain the locked in blocks from
 * tetrominos or are empty. The field doesn't contain the current tetromino.
 * It's ordered as a list of lines.
 * @typedef {Tetris.Line[]} Field
 * @memberof Tetris
 */

/**
 * A line is a horizontal list of 10 tetromino blocks.
 * @typedef {Tetris.Block_or_empty[]} Line
 * @memberof Tetris
 */

/**
 * A tetromino block on an empty space.
 * @typedef {(Tetris.Block | Tetris.Empty_block)} Block_or_empty
 * @memberof Tetris
 */

/**
 * Each tetromino is made of blocks. The blocks can correspond to the colour
 * of the tetromino they came from.
 * @typedef {("I" | "J" | "L" | "O" | "S" | "T" | "Z")} Block
 * @memberof Tetris
 */

/**
 * An empty space where a block could be.
 * @typedef {" "} Empty_block
 * @memberof Tetris
 */

/**
 * A tetromino is an arrangement of four blocks connected orthogonally.
 * Tetrominos express their own rotation state.
 * @typedef {object} Tetromino
 * @memberof Tetris
 * @property {Tetris.Block} block_type The type of the tetromino.
 * @property {number[]} centre Centre of rotation.
 * @property {Tetris.Block_or_empty[][]} grid The arrangement of the blocks.
 */

/**
 * A bag generates sequences of tetrominos.
 * It is a function that returns the next tetromino and a new bag.
 * The bag is an abstraction, there need not be a well defined contents.
 * @typedef {function} Tetromino_bag
 * @memberof Tetris
 * @returns {array&lt;(Tetris.Tetromino | Tetris.Tetromino_bag)>}
 * @example
 * const [next_piece, next_bag] = bag();
 */

//----------------------------------------------------------------------------//
// ## Constant Members                                                        //
//----------------------------------------------------------------------------//

/**
 * I Tetromino
 * &lt;pre>
 * 🟫🟫🟫🟫
 * &lt;/pre>
 * @constant {Tetris.Tetromino}
 * @memberof Tetris
 */
Tetris.I_tetromino = Object.freeze({
  block_type: 'I',
  centre: [1, 0],
  grid: [['I', 'I', 'I', 'I']],
});

/**
 * J Tetromino
 * &lt;pre>
 * 🟧⬛⬛
 * 🟧🟧🟧
 * &lt;/pre>
 * @constant {Tetris.Tetromino}
 * @memberof Tetris
 */
Tetris.J_tetromino = Object.freeze({
  block_type: 'J',
  centre: [1, 0],
  grid: [
    ['J', 'J', 'J'],
    [' ', ' ', 'J'],
  ],
});

/**
 * L Tetromino
 * &lt;pre>
 * 🟦🟦🟦
 * 🟦⬛⬛
 * &lt;/pre>
 * @constant {Tetris.Tetromino}
 * @memberof Tetris
 */
Tetris.L_tetromino = Object.freeze({
  block_type: 'L',
  centre: [1, 0],
  grid: [
    ['L', 'L', 'L'],
    ['L', ' ', ' '],
  ],
});

/**
 * O Tetromino
 * &lt;pre>
 * 🟨🟨
 * 🟨🟨
 * &lt;/pre>
 * @constant {Tetris.Tetromino}
 * @memberof Tetris
 */
Tetris.O_tetromino = Object.freeze({
  block_type: 'O',
  centre: [0.5, 0.5],
  grid: [
    ['O', 'O'],
    ['O', 'O'],
  ],
});

/**
 * S Tetromino
 * &lt;pre>
 * ⬛🟩🟩
 * 🟩🟩⬛
 * &lt;/pre>
 * @constant {Tetris.Tetromino}
 * @memberof Tetris
 */
Tetris.S_tetromino = Object.freeze({
  block_type: 'S',
  centre: [1, 0],
  grid: [
    [' ', 'S', 'S'],
    ['S', 'S', ' '],
  ],
});

/**
 * T Tetromino
 * &lt;pre>
 * ⬛🟪⬛
 * 🟪🟪🟪
 * &lt;/pre>
 * @constant {Tetris.Tetromino}
 * @memberof Tetris
 */
Tetris.T_tetromino = Object.freeze({
  block_type: 'T',
  centre: [1, 0],
  grid: [
    ['T', 'T', 'T'],
    [' ', 'T', ' '],
  ],
});

/**
 * Z Tetromino
 * &lt;pre>
 * 🟥🟥⬛
 * ⬛🟥🟥
 * &lt;/pre>
 * @constant {Tetris.Tetromino}
 * @memberof Tetris
 */
Tetris.Z_tetromino = Object.freeze({
  block_type: 'Z',
  centre: [1, 0],
  grid: [
    ['Z', 'Z', ' '],
    [' ', 'Z', 'Z'],
  ],
});

const empty_block = ' ';

const all_tetrominos = [Tetris.I_tetromino, Tetris.J_tetromino, Tetris.L_tetromino, Tetris.O_tetromino, Tetris.S_tetromino, Tetris.T_tetromino, Tetris.Z_tetromino];

/**
 * The height of a tetris field.
 * Includes buffer rows at the top that may not be visible.
 * @constant
 * @memberof Tetris
 * @default
 */
Tetris.field_height = 22;

/**
 * The visible height of a tetris field.
 * I.e. excluding the top buffer rows.
 * @constant
 * @memberof Tetris
 * @default
 */
Tetris.field_visible_height = 20;

/**
 * The width of a tetris field.
 * @constant
 * @memberof Tetris
 * @default
 */
Tetris.field_width = 10;

const starting_position = [Math.floor(Tetris.field_width / 2) - 1, 0];

//----------------------------------------------------------------------------//
// ## Methods                                                                 //
//----------------------------------------------------------------------------//

/**
 * Create a function to randomly obtain blocks and randomly select blocks from a given set of blocks
 * @param {Array} contents - Block Set
 * @returns {Function} - Returns a function that returns a random block and an updated set of blocks each time it is called
 */
const random_bag = function (contents) {
  return function () {
    if (contents.length === 0) {
      return new_bag();
    }
    // Random Generation
    const picked_index = Math.floor(contents.length * Math.random());
    const tetromino = contents[picked_index];
    const new_contents = contents.filter((ignore, index) => index !== picked_index);
    return [tetromino, random_bag(new_contents)];
  };
};

/**
 * Create a new set of blocks using all blocks
 */
const new_bag = random_bag(all_tetrominos);

/**
 * Create a new row
 * @returns {Array} - New row
 */
const new_line = function () {
  return R.repeat(empty_block, Tetris.field_width);
};

/**
 * Create a new gaming venue
 * @returns {Array} - New gaming venue
 */
const new_field = function () {
  return R.times(new_line, Tetris.field_height);
};

/**
 * Returns a game state for a new Tetris Game.
 * @function
 * @memberof Tetris
 * @returns {Tetris.Game} The new game.
 */
Tetris.new_game = function () {
  const [current_tetromino, next_bag] = new_bag();
  const [next_tetromino, bag] = next_bag();

  return {
    bag: bag,
    current_tetromino: current_tetromino,
    field: new_field(),
    game_over: false,
    next_tetromino: next_tetromino,
    position: starting_position,
    score: Score,
  };
};

/**
 * For a given tetromino and position,
 * return the coordinates of where its blocks would position in the field.
 * @function
 * @memberof Tetris
 * @param {Tetris.Tetromino} tetromino
 *     The current tetromino.
 * @param {number[]} position
 *     The coordinates `[x, y]` of the centre of the tetromino.
 * @returns {number[][]} The List of  coordinates `[x, y]` of each block.
 */
Tetris.tetromino_coordiates = function (tetromino, position) {
  return tetromino.grid.flatMap(function (row, row_index) {
    return row.flatMap(function (block, column_index) {
      if (block === empty_block) {
        return [];
      }
      return [[position[0] + column_index - Math.floor(tetromino.centre[0]), position[1] + row_index - Math.floor(tetromino.centre[1])]];
    });
  });
};

/**
 * Check if the bottom of the block is obstructed
 * @param {Object} tetromino - Current Block Object
 * @param {Array} position - The position coordinates of the current block
 * @returns {boolean} - Is the bottom of the block obstructed
 */
const is_blocked_bottom = function (tetromino, position) {
  return Tetris.tetromino_coordiates(tetromino, position).some(coord => coord[1] >= Tetris.field_height);
};

/**
 * Check if the left side of the block is obstructed
 * @param {Object} tetromino - Current Block Object
 * @param {Array} position - The position coordinates of the current block
 * @returns {boolean} - Is the left side of the block blocked
 */
const is_blocked_left = function (tetromino, position) {
  return Tetris.tetromino_coordiates(tetromino, position).some(coord => coord[0] &lt; 0);
};

/**
 * 检查方块是否右侧受阻
 * @param {Object} tetromino - Current Block Object
 * @param {Array} position - The position coordinates of the current block
 * @returns {boolean} - Is the right side of the block blocked
 */
const is_blocked_right = function (tetromino, position) {
  return Tetris.tetromino_coordiates(tetromino, position).some(coord => coord[0] >= Tetris.field_width);
};

/**
 * Check if the blocks are obstructed by the geometric structure of the site
 * @param {Array} field - Current game venue
 * @param {Object} tetromino - Current Block Object
 * @param {Array} position - The position coordinates of the current block
 * @returns {boolean} - Is the block obstructed by geometric structure
 */
const is_blocked_by_geometry = function (field, tetromino, position) {
  return Tetris.tetromino_coordiates(tetromino, position)
    .filter(coord => coord[0] >= 0 &amp;&amp; coord[0] &lt; Tetris.field_width &amp;&amp; coord[1] >= 0 &amp;&amp; coord[1] &lt; Tetris.field_height)
    .some(coord => field[coord[1]][coord[0]] !== empty_block);
};

/**
 * Check if the blocks are obstructed in any direction
 * @param {Array} field - Current game venue
 * @param {Object} tetromino - Current Block Object
 * @param {Array} position - The position coordinates of the current block
 * @returns {boolean} - Is the block blocked
 */
const is_blocked = function (field, tetromino, position) {
  return is_blocked_bottom(tetromino, position) || is_blocked_left(tetromino, position) || is_blocked_right(tetromino, position) || is_blocked_by_geometry(field, tetromino, position);
};

/**
 * Attempt to perform a left move on a game state.
 * If the current tetromino can be shifted once to the left, do so.
 * Otherwise return the origninal state unchanged.
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game The initial state of a game.
 * @returns {Tetris.Game} The state after a left move is attempted.
 */
Tetris.left = function (game) {
  if (Tetris.is_game_over(game)) {
    return game;
  }
  const new_position = [game.position[0] - 1, game.position[1]];
  if (is_blocked(game.field, game.current_tetromino, new_position)) {
    return game;
  }
  return R.mergeRight({ ...game, clear_lines: 0 }, { position: new_position });
};

/**
 * Attempt to perform a right move on a game state.
 * If the current tetromino can be shifted once to the right, do so.
 * Otherwise return the origninal state unchanged.
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game The initial state of a game.
 * @returns {Tetris.Game} The state after a right move is attempted.
 */
Tetris.right = function (game) {
  if (Tetris.is_game_over(game)) {
    return game;
  }
  const new_position = [game.position[0] + 1, game.position[1]];
  if (is_blocked(game.field, game.current_tetromino, new_position)) {
    return game;
  }
  return R.mergeRight({ ...game, clear_lines: 0 }, { position: new_position });
};

/**
 * Clockwise rotation of two-dimensional matrix
 * @param {Array} grid - 2D matrix to be rotated
 * @returns {Array} - Rotated two-dimensional matrix
 */
const rotate_grid_cw = R.pipe(R.reverse, R.transpose);

/**
 * Rotate a two-dimensional matrix counterclockwise
 * @param {Array} grid - 2D matrix to be rotated
 * @returns {Array} - Rotated two-dimensional matrix
 */
const rotate_grid_ccw = R.pipe(R.transpose, R.reverse);

/**
 * Rotate the block object clockwise
 * @param {Object} tetromino - Current Block Object
 * @returns {Object} - Rotated block object
 */
const rotate_tetromino_cw = function (tetromino) {
  return {
    block_type: tetromino.block_type,
    centre: [tetromino.grid.length - 1 - tetromino.centre[1], tetromino.centre[0]],
    grid: rotate_grid_cw(tetromino.grid),
  };
};

/**
 * Rotate the block object counterclockwise
 * @param {Object} tetromino - Current Block Object
 * @returns {Object} - Rotated block object
 */
const rotate_tetromino_ccw = function (tetromino) {
  return {
    block_type: tetromino.block_type,
    centre: [tetromino.centre[1], tetromino.grid[0].length - 1 - tetromino.centre[0]],
    grid: rotate_grid_ccw(tetromino.grid),
  };
};

/**
 * Attempt to perform a clockwise rotation on a game state.
 * If the current tetromino can be rotated clockwise, do so.
 * Otherwise return the origninal state unchanged.
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game The initial state of a game.
 * @returns {Tetris.Game} The state after a CW rotation is attempted.
 */
Tetris.rotate_cw = function (game) {
  if (Tetris.is_game_over(game)) {
    return game;
  }
  const new_rotation = rotate_tetromino_cw(game.current_tetromino);
  if (is_blocked(game.field, new_rotation, game.position)) {
    return game;
  }
  return R.mergeRight({ ...game, clear_lines: 0 }, { current_tetromino: new_rotation });
};

/**
 * Attempt to perform a counter-clockwise rotation on a game state.
 * If the current tetromino can be rotated counter-clockwise, do so.
 * Otherwise return the origninal state unchanged.
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game The initial state of a game.
 * @returns {Tetris.Game} The state after a CCW rotation is attempted.
 */
Tetris.rotate_ccw = function (game) {
  if (Tetris.is_game_over(game)) {
    return game;
  }
  const new_rotation = rotate_tetromino_ccw(game.current_tetromino);
  if (is_blocked(game.field, new_rotation, game.position)) {
    return game;
  }
  return R.mergeRight({ ...game, clear_lines: 0 }, { current_tetromino: new_rotation });
};

/**
 * 方块下降一格
 * @param {Object} game - Current game status
 * @param {number} points - Score earned
 * @returns {Object} - Game state after descent
 */
const descend = function (game, points = 0) {
  game = { ...game, clear_lines: 0 };
  const new_position = [game.position[0], game.position[1] + 1];
  if (is_blocked(game.field, game.current_tetromino, new_position)) {
    return game;
  }
  return R.mergeRight(game, { position: new_position, score: add_points(points) });
};

/**
 * Increase points and update point display
 * @param {number} points - Increased product score
 * @returns {Object} - Integral object
 */
function add_points(points) {
  Score.updateScore(points, true);
  return Score;
}

/**
 * Try to perform a soft descent, where the block moves down one grid.
 * This may accumulate additional points.
 * If the block cannot descend, return to its original state.
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game - The initial state of the game.
 * @param {boolean} isPoints - Is there an additional score to avoid soft_ Drop is frequently triggeredlet score = point || localStorage.getItem('soft_drop');
 * @param {number} points - Extra points.
 * @returns {Tetris.Game} - The state after attempting soft descent.
 */
Tetris.soft_drop = function (game, isPoints = false, point) {
  // Check if the game is over
  if (Tetris.is_game_over(game)) {
    return game;
  }

  let score = point || localStorage.getItem('soft_drop');

  if (score &amp;&amp; !isPoints) {
    // If there were previously saved scores, use them and delete them from local storage
    localStorage.removeItem('soft_drop');
  } else if (!score &amp;&amp; !isPoints) {
    score = 0;
    // Otherwise, if there is no specified score, set it to 0
  }

  // 进行软降操作，并将分数转换为数字类型
  return descend(game, Number(score));
};

/**
 * Perform a hard descent, which means that the block immediately and completely descends until it bottoms out or touches another block.
 * This may accumulate additional points.
 * Hard descent will immediately enter the next round.
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game - The initial state of the game.
 * @param {number} points - Extra points.
 * @returns {Tetris.Game} - The state after attempting a hard descent.
 */
Tetris.hard_drop = function (game, points) {
  // Check if the game is over
  if (Tetris.is_game_over(game)) {
    return game;
  }

  let score = points != undefined ? points : localStorage.getItem('hard_drop');

  // If there were previously saved scores, use them and delete them from local storage
  if (score &amp;&amp; !points) {
    localStorage.removeItem('hard_drop');
  } else if (!score &amp;&amp; !points) {
    // Otherwise, if there is no specified score, set it to 0
    score = 0;
  }

  // Perform a soft descent operation and convert the score to a numeric type
  const dropped_once = descend(game, Number(score));
  if (R.equals(game, dropped_once)) {
    // If the block cannot descend, immediately enter the next round
    return Tetris.next_turn(game);
  }
  // Continue hard descent until the block cannot descend again
  return Tetris.hard_drop(dropped_once, 0);
};

/**
 * Game failed
 * @param {Object} game - Current game status
 * @returns {Object} - Game status after failure
 */
const lose = R.set(R.lensProp('game_over'), true);

/**
 * Lock blocks to the game field
 * @param {Object} game - Current game status
 * @returns {Array} - Updated gaming venue
 */
const lock = function (game) {
  const updated_field = R.clone(game.field);
  const coords = Tetris.tetromino_coordiates(game.current_tetromino, game.position);
  coords.forEach(function (coord) {
    updated_field[coord[1]][coord[0]] = game.current_tetromino.block_type;
  });
  return updated_field;
};

/**
 * Check if a line is complete
 * @param {Array} line - Lines to be checked
 * @returns {boolean} - Is the line complete
 */
const is_complete_line = line => !line.some(block => block === empty_block);

/**
 * Fill in the game field and fill in the missing rows
 * @param {Array} short_field - Incomplete gaming venue
 * @returns {Array} - Completed game venue
 */
const pad_field = function (short_field) {
  const missing_row_count = Tetris.field_height - short_field.length;
  const new_rows = R.times(new_line, missing_row_count);
  return [...new_rows, ...short_field];
};

/**
 * Clear the complete rows and make up for the missing rows in the field
 * @param {Array} field - Current game venue
 * @returns {Array} - Updated gaming venue
 */
const clear_lines = R.pipe(R.reject(is_complete_line), pad_field);

/**
 * next_turn advances the Tetris game.
 * It will attempt to descend the current tetromino once.
 * If this is possible, that game state is returned.
 * Otherwise it checks if the game is lost (The current state is blocked)
 * Then otherwise will lock the current tetromino in place and deploy the next
 * from the top of the field.
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game
 * @returns {Tetris.Game}
 */
Tetris.next_turn = function (game, type) {
  if (game.game_over) {
    return game;
  }

  // If the current piece can descend, do that.
  const descended = descend({ ...game, clear_lines: 0 });
  if (!R.equals(game, descended)) {
    return descended;
  }

  // Is the current piece on top of a locked in piece?
  // I.e. it's just been deployed and something is in the way.
  // In this case, lose the game.
  if (is_blocked_by_geometry(game.field, game.current_tetromino, game.position)) {
    return lose(game);
  }

  // Otherwise, we can't descend and we've not lost,
  // So lock the current piece in place and deploy the next.
  let locked_field = lock(game);

  const cleared_field = clear_lines(locked_field);

  const [next_tetromino, bag] = game.bag();

  let clearLines = locked_field.filter(parItem => parItem.every(childItem => childItem !== ' ')).length;

  // console.log(clearLines, 'clearLines');

  if (locked_field.filter(parItem => parItem.every(childItem => childItem !== ' ')).length) {
    Score.updateClearLines(clearLines);
  }

  return {
    bag: bag,
    current_tetromino: game.next_tetromino,
    field: cleared_field,
    // 清除的行数
    clear_lines: clearLines,
    game_over: false,
    next_tetromino: next_tetromino,
    position: starting_position,
    score: Score,
  };
};

/**
 * @function
 * @memberof Tetris
 * @param {Tetris.Game} game The game to check is over or in play.
 * @returns {boolean} Whether the game is over or not.
 */
Tetris.is_game_over = function (game) {
  return game.game_over;
};

export default Object.freeze(Tetris);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Score.html">Score</a></li><li><a href="Tetris.html">Tetris</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add_points">add_points</a></li><li><a href="global.html#clear_lines">clear_lines</a></li><li><a href="global.html#cleared_lines">cleared_lines</a></li><li><a href="global.html#descend">descend</a></li><li><a href="global.html#is_blocked">is_blocked</a></li><li><a href="global.html#is_blocked_bottom">is_blocked_bottom</a></li><li><a href="global.html#is_blocked_by_geometry">is_blocked_by_geometry</a></li><li><a href="global.html#is_blocked_left">is_blocked_left</a></li><li><a href="global.html#is_blocked_right">is_blocked_right</a></li><li><a href="global.html#is_complete_line">is_complete_line</a></li><li><a href="global.html#judgmentScore">judgmentScore</a></li><li><a href="global.html#lock">lock</a></li><li><a href="global.html#lose">lose</a></li><li><a href="global.html#new_bag">new_bag</a></li><li><a href="global.html#new_field">new_field</a></li><li><a href="global.html#new_line">new_line</a></li><li><a href="global.html#pad_field">pad_field</a></li><li><a href="global.html#random_bag">random_bag</a></li><li><a href="global.html#rotate_grid_ccw">rotate_grid_ccw</a></li><li><a href="global.html#rotate_grid_cw">rotate_grid_cw</a></li><li><a href="global.html#rotate_tetromino_ccw">rotate_tetromino_ccw</a></li><li><a href="global.html#rotate_tetromino_cw">rotate_tetromino_cw</a></li><li><a href="global.html#update_scoreboard">update_scoreboard</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sun Aug 06 2023 14:38:33 GMT+0800 (GMT+08:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
